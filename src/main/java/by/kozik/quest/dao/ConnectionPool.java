package by.kozik.quest.dao;

import by.kozik.quest.exception.PoolConnectionException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by Serge on 07.12.2016.
 *
 * to do:
 *          waiting time for getting
 *          check autocommit after return
 *
 */
public class ConnectionPool {

    private static ConnectionPool instance;
    private static ReentrantLock lockArray = new ReentrantLock();
    private static Condition availableCondition = lockArray.newCondition();
    private static AtomicBoolean flagCreated = new AtomicBoolean(false);
    private static Driver sqlDriver = null;
    private static Logger logger = LogManager.getLogger();

    private List<InnerConnection> pool;
    private long waitTimeNanosec;
    private AtomicInteger numAvailable = new AtomicInteger();

    private class InnerConnection implements ConnectionUsable {
        private Connection connection;
        private boolean working;

        boolean isWorking() {
            return working;
        }

        void setWorking(boolean working) {
            this.working = working;
        }

        InnerConnection(Connection connection) {
            this.connection = connection;
        }

        @Override
        public Statement createStatement() throws SQLException {
            return connection.createStatement();
        }

        @Override
        public void close() throws SQLException {
            if (working) {
                try{
                    lockArray.lock();
                    numAvailable.incrementAndGet();
                    connection.setAutoCommit(true);
                    working=false;
                    availableCondition.signal();
                } finally {
                    lockArray.unlock();
                }
            }
        }

        @Override
        public void closeResources(Statement statement) {
            try {
                if (statement != null) {
                    statement.close();
                }
                if (this.working) {
                    this.close();
                }

            } catch (SQLException se) {
                logger.error("SQL error while connection closing."+se.getMessage());
            }
        }

        @Override
        public void commit() throws SQLException {
            connection.commit();
        }

        @Override
        public boolean isClosed() throws SQLException {
            return connection.isClosed();
        }

        @Override
        public PreparedStatement prepareStatement(String sql) throws SQLException {
            return connection.prepareStatement(sql);
        }

        @Override
        public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
            return connection.prepareStatement(sql,autoGeneratedKeys);
        }

        @Override
        public void rollback() throws SQLException {
            connection.rollback();
        }

        @Override
        public void setAutoCommit(boolean flag) throws SQLException {
            connection.setAutoCommit(flag);
        }

        private void reallyClose() throws SQLException {
            lockArray.lock();
            working=false;
            connection.close();
            numAvailable.incrementAndGet();
            lockArray.unlock();
        }
    }

    private ConnectionPool(int poolSize, int waitTimeMillisec,String dbURL, String login, String password) throws SQLException {
        pool = new ArrayList<>();
        sqlDriver = new com.mysql.jdbc.Driver();
        DriverManager.registerDriver(sqlDriver);
        this.waitTimeNanosec = new Double(waitTimeMillisec*1e6).longValue();
        for (int i=0;i<poolSize;i++) {
            Connection connection = DriverManager.getConnection(dbURL,login,password);
            InnerConnection innerConnection = new InnerConnection(connection);
            pool.add(innerConnection);
        }
        numAvailable.set(poolSize);
    }

    public static void startPool(int poolSize, int waitTimeMillisec,String dbURL, String login, String password) {
        if (!flagCreated.get()) {
            lockArray.lock();
            try {
                if (instance==null) {
                    instance = new ConnectionPool(poolSize, waitTimeMillisec, dbURL, login, password);
                    flagCreated.set(true);
                }
            } catch (SQLException e) {
                logger.fatal("Connection Pool was not started.");
                throw new RuntimeException(e.getMessage(),e);
            } finally {
                lockArray.unlock();
            }
        }
    }

    public static ConnectionPool getInstance() {
        return instance;
    }

    public InnerConnection takeConnection() throws SQLException,PoolConnectionException {
        InnerConnection result=null;
        lockArray.lock();
        try {
            while (numAvailable.get()<=0) {
                availableCondition.awaitNanos(waitTimeNanosec);
            }
            for (InnerConnection item:pool) {
                if ((!item.isWorking())&&(!item.isClosed())) {
                    result = item;
                    item.setWorking(true);
                    numAvailable.decrementAndGet();
                    break;
                }
            }
        } catch (InterruptedException e) {
            throw new PoolConnectionException(e);
        }
        finally {
            lockArray.unlock();
        }
        if (result==null) {
            throw new PoolConnectionException("No available connections.");
        }
        return result;
    }

    public void closeAllResources() {
        try {
            for (int ii=0; ii<pool.size(); ii++) {
                InnerConnection connection = null;
                try {
                    connection = takeConnection();
                    if (!connection.isClosed()) {
                        connection.reallyClose();
                    }
                } catch (PoolConnectionException e) {
                    for (InnerConnection item:pool) {
                        if (item.isWorking()) {
                            item.reallyClose();
                            break;
                        }
                    }
                }
            }
            numAvailable.set(0);
        } catch (SQLException ee) {
            logger.error("Error while stopping connection pool.");
        } finally {
            try {
                DriverManager.deregisterDriver(sqlDriver);
            } catch (SQLException e) {
                logger.error("Error during deregistering driver "+sqlDriver);
            }
            pool.clear();
            pool=null;
            flagCreated.set(false);
        }
    }

    public int getNumAvailable() {
        return numAvailable.get();
    }
}
